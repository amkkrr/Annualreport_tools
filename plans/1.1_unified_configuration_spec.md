# 1.1 统一配置管理 (Unified Configuration Management) 规格书

**状态**: Draft v2 (审计后修订)
**负责人**: Architect
**相关 Issue**: P0 - 1.1 统一配置管理
**修订历史**:
- v2 (2025-01): 根据审计报告修订，修复 P0-P2 问题

## 1. 背景与目标

当前项目包含多个独立脚本 (`crawler`, `converter`, `analysis`, `mda_extractor`)，每个脚本的配置方式不统一，主要依赖：
- 脚本底部的 `if __name__ == "__main__":` 硬编码常量。
- 命令行参数 (`argparse`)。
- 简单的局部变量。

这种分散的配置管理导致：
1.  **维护困难**：修改年份或路径需要修改多个文件。
2.  **易错性**：硬编码容易导致误提交个人配置。
3.  **扩展性差**：难以在不同环境下（开发、生产）切换配置。

**本规格书的目标**是设计一套统一的配置管理方案，通过 YAML 文件集中管理所有非敏感配置，并使用 Pydantic 进行强类型校验，确保配置的安全性和一致性。

## 2. 核心设计

### 2.1 配置文件格式 (`config.yaml`)

采用 YAML 作为配置文件格式，支持层级结构和注释。

> **术语统一**: 本项目统一使用 `crawler` 作为爬虫模块的术语（与脚本文件名 `1.report_link_crawler.py` 保持一致）。

```yaml
# 全局项目配置
project:
  # 基础工作目录，所有相对路径将基于此解析（详见 2.5 路径归一化）
  workspace_root: "."
  # 默认日志级别: DEBUG, INFO, WARNING, ERROR
  log_level: "INFO"

# 数据库配置 (DuckDB)
database:
  path: "data/annual_reports.duckdb"

# 1. 爬虫模块配置 (Crawler)
crawler:
  # 目标年份列表，支持单年或多年
  target_years: [2023]

  # 请求控制
  request:
    timeout: 10
    max_retries: 3
    retry_delay: 5

  # 过滤条件
  filters:
    # 板块列表: sz, sh, szmb, shmb, szcy, shkcp, bj
    plates: ["sz", "sh"]
    # 行业，留空表示全部
    trade: ""
    # 标题排除关键词
    exclude_keywords:
      - "英文"
      - "已取消"
      - "摘要"
      - "更正后"

  # 输出配置
  output:
    # 结果 Excel 路径模板，{year} 会被自动替换
    excel_path_template: "res/AnnualReport_links_{year}.xlsx"
    save_interval: 100

# 2. 下载与转换模块配置 (Downloader & Converter)
downloader:
  # 并发进程数，null 表示自动 (CPU核心数)
  processes: null

  # 路径配置
  paths:
    # 输入 Excel 路径模板 (通常与 crawler.output.excel_path_template 一致)
    input_excel_template: "res/AnnualReport_links_{year}.xlsx"
    # PDF 下载目录模板
    pdf_dir_template: "outputs/annual_reports/{year}/pdf"
    # TXT 转换目录模板
    txt_dir_template: "outputs/annual_reports/{year}/txt"

  behavior:
    # 下载完成后是否删除 PDF
    delete_pdf: false
    # 是否跳过已存在的 TXT
    skip_existing: true
    # 强制覆盖模式
    force_overwrite: false

  # 下载请求配置（独立于爬虫配置）
  request:
    timeout: 30
    max_retries: 3
    chunk_size: 8192
    # 下载专用配置
    stream: true
    headers:
      User-Agent: "Mozilla/5.0"

# 3. 文本分析模块配置 (Analysis)
analysis:
  # 关键词列表（不能为空）
  keywords:
    - "人工智能"
    - "商业智能"
    - "大数据"
    - "数据挖掘"
    - "数字化转型"

  paths:
    # 分析结果输出路径，{timestamp} 格式为 YYYYMMDD_HHMMSS（本地时区）
    output_excel: "outputs/analysis/keyword_counts_{timestamp}.xls"
    # 待分析的文本根目录
    text_root_dir: "outputs/annual_reports"

# 4. MDA 提取模块配置 (MDA Extractor)
mda:
  limits:
    max_pages: 50
    max_chars: 200000

  behavior:
    # 增量更新模式
    incremental: true
    workers: 4
```

### 2.2 配置定义 (Pydantic Models)

> **版本要求**: 本规格书采用 **Pydantic v2** (`pydantic>=2.0,<3.0`)。选择 v2 的理由：
> - 性能显著提升（Rust 核心）
> - 更清晰的 API（`field_validator` 替代 `@validator`）
> - 更好的类型推断支持
>
> **与项目规范的兼容性**: 项目原有规范要求使用 `dataclass` 定义配置。本规格书采用 **方案 A（适配层模式）**：
> - Pydantic 模型仅用于 **加载与校验** 阶段
> - 校验通过后转换为 `dataclass` 实例供业务代码使用
> - 保持业务代码与 Pydantic 解耦，便于测试和维护

将新建 `config_manager.py` 模块，定义如下数据结构：

```python
from dataclasses import dataclass as py_dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

from pydantic import BaseModel, Field, field_validator, model_validator

# ============ 基础配置类 ============

class ProjectConfig(BaseModel):
    workspace_root: Path = Field(default=Path("."))
    log_level: str = Field(default="INFO", pattern="^(DEBUG|INFO|WARNING|ERROR)$")

class DatabaseConfig(BaseModel):
    path: Path = Field(default=Path("data/annual_reports.duckdb"))

# ============ 爬虫配置 ============

class CrawlerRequestConfig(BaseModel):
    """爬虫专用请求配置"""
    timeout: int = Field(default=10, ge=1, le=300)
    max_retries: int = Field(default=3, ge=0, le=10)
    retry_delay: int = Field(default=5, ge=1, le=60)

class CrawlerFiltersConfig(BaseModel):
    plates: List[str] = Field(default_factory=lambda: ["sz", "sh"])
    trade: str = ""
    exclude_keywords: List[str] = Field(default_factory=list)

    @field_validator('plates')
    @classmethod
    def check_plates(cls, v):
        valid_plates = {"sz", "sh", "szmb", "shmb", "szcy", "shkcp", "bj"}
        for plate in v:
            if plate not in valid_plates:
                raise ValueError(f"Invalid plate '{plate}'. Valid: {valid_plates}")
        return v

class CrawlerOutputConfig(BaseModel):
    excel_path_template: str = "res/AnnualReport_links_{year}.xlsx"
    save_interval: int = Field(default=100, ge=1)

class CrawlerConfig(BaseModel):
    target_years: List[int] = Field(min_length=1)
    request: CrawlerRequestConfig = Field(default_factory=CrawlerRequestConfig)
    filters: CrawlerFiltersConfig = Field(default_factory=CrawlerFiltersConfig)
    output: CrawlerOutputConfig = Field(default_factory=CrawlerOutputConfig)

    @field_validator('target_years')
    @classmethod
    def check_years(cls, v):
        for year in v:
            if year < 1990 or year > 2100:
                raise ValueError(f"Year {year} is out of reasonable range [1990, 2100]")
        return v

# ============ 下载器配置（独立于爬虫） ============

class DownloaderRequestConfig(BaseModel):
    """下载器专用请求配置（与爬虫不同）"""
    timeout: int = Field(default=30, ge=1, le=600)
    max_retries: int = Field(default=3, ge=0, le=10)
    chunk_size: int = Field(default=8192, ge=1024, le=1048576)
    stream: bool = True
    headers: Dict[str, str] = Field(default_factory=lambda: {"User-Agent": "Mozilla/5.0"})

class DownloaderPathsConfig(BaseModel):
    input_excel_template: str
    pdf_dir_template: str
    txt_dir_template: str

class DownloaderBehaviorConfig(BaseModel):
    delete_pdf: bool = False
    skip_existing: bool = True
    force_overwrite: bool = False

class DownloaderConfig(BaseModel):
    processes: Optional[int] = Field(default=None, ge=1, le=64)
    paths: DownloaderPathsConfig
    behavior: DownloaderBehaviorConfig = Field(default_factory=DownloaderBehaviorConfig)
    request: DownloaderRequestConfig = Field(default_factory=DownloaderRequestConfig)

# ============ 分析配置 ============

class AnalysisPathsConfig(BaseModel):
    output_excel: str
    text_root_dir: str

class AnalysisConfig(BaseModel):
    keywords: List[str] = Field(min_length=1)
    paths: AnalysisPathsConfig

# ============ MDA 配置 ============

class MdaLimitsConfig(BaseModel):
    max_pages: int = Field(default=50, ge=1, le=500)
    max_chars: int = Field(default=200000, ge=1000)

class MdaBehaviorConfig(BaseModel):
    incremental: bool = True
    workers: int = Field(default=4, ge=1, le=32)

class MdaConfig(BaseModel):
    limits: MdaLimitsConfig = Field(default_factory=MdaLimitsConfig)
    behavior: MdaBehaviorConfig = Field(default_factory=MdaBehaviorConfig)

# ============ 全局配置 ============

class GlobalConfig(BaseModel):
    project: ProjectConfig = Field(default_factory=ProjectConfig)
    database: DatabaseConfig = Field(default_factory=DatabaseConfig)
    crawler: CrawlerConfig
    downloader: DownloaderConfig
    analysis: AnalysisConfig
    mda: MdaConfig = Field(default_factory=MdaConfig)

    @model_validator(mode='after')
    def normalize_paths(self):
        """路径归一化：将所有相对路径转换为基于 workspace_root 的绝对路径"""
        # 详见 2.5 路径归一化章节
        return self
```

### 2.3 加载与优先级策略

配置加载的优先级如下（由高到低）：
1.  **命令行参数 (CLI Arguments)**: 显式传递的参数优先级最高（例如 `--year 2024`）。
2.  **环境变量 (Environment Variables)**: 如 `ANNUAL_REPORT_CONFIG_PATH` 指定的配置文件。
3.  **配置文件 (config.yaml)**: 默认位于项目根目录的 `config.yaml`。
4.  **默认值 (Code Defaults)**: Pydantic 模型中定义的默认值。

#### 2.3.1 CLI 覆盖映射表

CLI 参数使用 **替换语义（Replace）**，即 CLI 值完全覆盖配置文件中的对应值（列表不做追加/合并）。

| CLI 参数 | 配置路径 | 类型 | 覆盖语义 | 示例 |
|---------|---------|------|---------|------|
| `--year` / `-y` | `crawler.target_years` | `List[int]` | 替换整个列表 | `--year 2023 2024` |
| `--processes` / `-p` | `downloader.processes` | `int` | 替换 | `--processes 8` |
| `--text-dir` | `analysis.paths.text_root_dir` | `str` | 替换 | `--text-dir outputs/txt` |
| `--workers` / `-w` | `mda.behavior.workers` | `int` | 替换 | `--workers 8` |
| `--timeout` | `crawler.request.timeout` | `int` | 替换 | `--timeout 30` |
| `--download-timeout` | `downloader.request.timeout` | `int` | 替换 | `--download-timeout 60` |
| `--log-level` | `project.log_level` | `str` | 替换 | `--log-level DEBUG` |
| `--config` / `-c` | (配置文件路径) | `str` | - | `--config custom.yaml` |
| `--force` / `-f` | `downloader.behavior.force_overwrite` | `bool` | 设为 True | `--force` |
| `--incremental` | `mda.behavior.incremental` | `bool` | 设为 True | `--incremental` |

#### 2.3.2 覆盖实现示例

```python
import argparse
from typing import Any, Dict

def apply_cli_overrides(config: GlobalConfig, args: argparse.Namespace) -> GlobalConfig:
    """将 CLI 参数覆盖到配置对象（不可变更新）"""
    overrides: Dict[str, Any] = {}

    if args.year:
        overrides["crawler"] = {**config.crawler.model_dump(), "target_years": args.year}
    if args.processes:
        overrides["downloader"] = {
            **config.downloader.model_dump(),
            "processes": args.processes
        }
    if args.workers:
        mda_dump = config.mda.model_dump()
        mda_dump["behavior"]["workers"] = args.workers
        overrides["mda"] = mda_dump

    if overrides:
        return config.model_copy(update=overrides)
    return config
```

**迁移策略**:
- 现有脚本保留 `argparse` 逻辑。
- 在 `main` 函数开始处，尝试加载 `config.yaml`。
- 将 `config.yaml` 的值作为 `default` 值注入到 `argparse` 或者在解析后合并。
- 推荐做法：**使用 Config 对象作为单一数据源**。命令行参数解析后，用来覆盖 Config 对象中的对应字段。

### 2.4 配置文件缺失策略

采用 **强制模式**：配置文件必须存在，缺失时程序启动失败并提供友好提示。

```python
def load_config(path: str = "config.yaml") -> GlobalConfig:
    """加载配置文件，缺失时报错并提示"""
    config_path = Path(path)

    if not config_path.exists():
        example_path = Path("config.yaml.example")
        hint = ""
        if example_path.exists():
            hint = f"\n提示: 可复制模板文件创建配置:\n  cp {example_path} {config_path}"
        raise FileNotFoundError(
            f"配置文件不存在: {config_path}{hint}\n"
            f"或使用 --config 参数指定配置文件路径"
        )

    with open(config_path, "r", encoding="utf-8") as f:
        raw = yaml.safe_load(f)

    return GlobalConfig.model_validate(raw)
```

### 2.5 路径归一化与安全校验

#### 2.5.1 路径归一化流程

所有路径字段在加载后统一归一化为基于 `workspace_root` 的绝对路径：

```python
from pathlib import Path

class PathNormalizer:
    """路径归一化器"""

    # 禁止写入的系统目录前缀（跨平台）
    FORBIDDEN_PREFIXES_UNIX = ["/etc", "/usr", "/bin", "/sbin", "/var", "/root", "/boot"]
    FORBIDDEN_PREFIXES_WIN = ["C:\\Windows", "C:\\Program Files"]

    # 项目源代码目录（禁止作为输出目录）
    SOURCE_DIRS = ["annual_report_mda", "tests", ".git"]

    def __init__(self, workspace_root: Path):
        self.workspace_root = workspace_root.resolve()

    def normalize(self, path: str | Path) -> Path:
        """将路径归一化为绝对路径"""
        p = Path(path)
        if p.is_absolute():
            return p.resolve()
        return (self.workspace_root / p).resolve()

    def validate_output_path(self, path: Path) -> None:
        """校验输出路径安全性"""
        resolved = path.resolve()
        path_str = str(resolved)

        # 1. 禁止系统目录
        import platform
        if platform.system() != "Windows":
            for prefix in self.FORBIDDEN_PREFIXES_UNIX:
                if path_str.startswith(prefix):
                    raise ValueError(f"禁止写入系统目录: {path_str}")
        else:
            for prefix in self.FORBIDDEN_PREFIXES_WIN:
                if path_str.lower().startswith(prefix.lower()):
                    raise ValueError(f"禁止写入系统目录: {path_str}")

        # 2. 禁止写入项目源代码目录
        for src_dir in self.SOURCE_DIRS:
            src_path = (self.workspace_root / src_dir).resolve()
            if resolved == src_path or str(resolved).startswith(str(src_path) + "/"):
                raise ValueError(f"禁止写入源代码目录: {path_str}")

        # 3. 禁止写入根目录
        if resolved == Path("/").resolve() or resolved == Path("C:\\").resolve():
            raise ValueError(f"禁止写入根目录: {path_str}")
```

#### 2.5.2 路径归一化在模型加载后执行

```python
@model_validator(mode='after')
def normalize_paths(self) -> "GlobalConfig":
    """在模型验证后执行路径归一化"""
    normalizer = PathNormalizer(self.project.workspace_root)

    # 归一化数据库路径
    self.database.path = normalizer.normalize(self.database.path)

    # 归一化并校验输出路径
    for template in [
        self.downloader.paths.pdf_dir_template,
        self.downloader.paths.txt_dir_template,
    ]:
        # 模板路径用占位符测试
        test_path = normalizer.normalize(template.replace("{year}", "2023"))
        normalizer.validate_output_path(test_path)

    return self
```

### 2.6 错误提示规范

配置校验失败时，必须输出用户可读的错误信息，包含：

1. **错误位置**：具体字段路径（如 `crawler.target_years[0]`）
2. **期望值**：期望的类型/范围/格式
3. **实际值**：用户提供的值
4. **修复建议**：示例配置片段

```python
from pydantic import ValidationError

def format_validation_error(e: ValidationError, config_path: str) -> str:
    """格式化验证错误为用户可读信息"""
    lines = [f"配置文件 {config_path} 校验失败:"]

    for error in e.errors():
        loc = ".".join(str(x) for x in error["loc"])
        msg = error["msg"]
        input_val = error.get("input", "N/A")

        lines.append(f"\n  字段: {loc}")
        lines.append(f"  错误: {msg}")
        lines.append(f"  输入值: {input_val}")

        # 添加修复建议
        if "year" in loc.lower() and "range" in msg.lower():
            lines.append("  建议: target_years 应为 1990-2100 之间的年份列表，如 [2022, 2023]")

    return "\n".join(lines)
```

## 3. 实现步骤

1.  **基础建设**:
    - 添加 `PyYAML>=6.0` 和 `pydantic>=2.0,<3.0` 到 `requirements.txt`。
    - 创建 `config.yaml.example` 模板文件（与 2.1 配置示例一致）。
    - 将 `config.yaml` 添加到 `.gitignore`（个人配置不提交）。

2.  **代码实现**:
    - 创建 `annual_report_mda/config_manager.py`。
    - 实现 `load_config(path: str = "config.yaml") -> GlobalConfig` 函数。
    - 实现 `PathNormalizer` 类与路径安全校验。
    - 实现 `format_validation_error()` 错误格式化函数。

3.  **脚本改造**（渐进式，每阶段完成后验证再进入下一阶段）:
    - **Phase 1**: 改造 `1.report_link_crawler.py`。引入 `load_config`，用 `config.crawler` 替换底部的常量配置。
    - **Phase 2**: 改造 `2.pdf_batch_converter.py`。用 `config.downloader` 替换配置。
    - **Phase 3**: 改造 `3.text_analysis.py`。用 `config.analysis` 替换配置，特别是关键词列表。
    - **Phase 4**: 改造 `mda_extractor.py`。

## 4. 安全与校验规则

为防止误操作，必须实施以下校验：

1.  **路径安全**:
    - 禁止输出目录为系统根目录 (`/`, `C:\`)。
    - 禁止输出目录写入系统目录（`/etc`, `/usr`, `/bin`, `/var`, `/root` 等）。
    - 禁止输出目录覆盖项目源代码目录（`annual_report_mda/`, `tests/`, `.git/`）。
    - 所有相对路径必须基于 `workspace_root` 解析后再校验。
2.  **文件覆盖**:
    - 如果输出文件已存在且未开启 `force_overwrite`，应报错或跳过，并记录日志。
3.  **空值校验**:
    - 关键词列表不能为空（`min_length=1`）。
    - 目标年份列表不能为空（`min_length=1`）。
4.  **类型与范围校验**:
    - 所有数值字段使用 `ge`/`le` 约束范围。
    - 枚举字段（如 `plates`）使用白名单校验。

## 5. 验收标准

### 5.1 基础功能

| ID | 验收项 | 验证方法 |
|----|-------|---------|
| M1-01 | 配置加载 | 能正确读取 `config.yaml` 并解析为 `GlobalConfig` 对象 |
| M1-02 | 校验生效 | 非法值（如 `year=3000`、空关键词列表）抛出清晰的 `ValidationError` |
| M1-03 | 命令行覆盖 | `python script.py --year 2025` 覆盖 `config.yaml` 中的 `target_years` |
| M1-04 | 配置缺失 | 无 `config.yaml` 时报错并提示复制 `config.yaml.example` |

### 5.2 路径与安全

| ID | 验收项 | 验证方法 |
|----|-------|---------|
| M1-05 | 路径归一化 | 相对路径正确基于 `workspace_root` 解析为绝对路径 |
| M1-06 | 系统目录禁写 | 尝试设置 `pdf_dir_template: "/etc/reports"` 时报错 |
| M1-07 | 源码目录禁写 | 尝试设置 `txt_dir_template: "annual_report_mda"` 时报错 |

### 5.3 CLI 覆盖

| ID | 验收项 | 验证方法 |
|----|-------|---------|
| M1-08 | 嵌套字段覆盖 | `--download-timeout 60` 正确覆盖 `downloader.request.timeout` |
| M1-09 | 列表字段替换 | `--year 2023 2024` 完全替换（非追加）`target_years` |

### 5.4 一致性

| ID | 验收项 | 验证方法 |
|----|-------|---------|
| M1-10 | 模板一致性 | `config.yaml.example` 与 Pydantic 模型字段保持一致（CI 校验） |
| M1-11 | 术语一致性 | YAML 键名与代码模型属性名一致（`crawler` 非 `spider`） |

## 6. 问题与风险

- **兼容性**: 旧版脚本深度依赖全局常量，改造过程需小心，避免破坏原有逻辑。建议采用渐进式迁移，每个 Phase 完成后运行完整测试。
- **依赖冲突**: Pydantic v2 与旧版 API 不兼容。如环境中存在依赖 Pydantic v1 的库，需评估升级影响。
- **向后兼容**: 旧脚本硬编码常量的默认值需与新配置默认值保持一致，避免行为变化。

## 7. 扩展章节（审计建议补充）

### 7.1 配置分层与 Profile

支持多配置文件叠加，便于区分开发/生产环境：

```
config.yaml              # 基础配置
config.local.yaml        # 本地覆盖（.gitignore）
config.production.yaml   # 生产环境配置
```

加载顺序：`config.yaml` → `config.{PROFILE}.yaml` → `config.local.yaml`

通过环境变量 `ANNUAL_REPORT_PROFILE=production` 选择 profile。

### 7.2 敏感信息处理

当前配置仅包含非敏感信息。未来如需支持敏感配置（API Token、代理密码等），建议：

1. 敏感字段从 YAML 移至环境变量或 `.env` 文件
2. 使用 `pydantic-settings` 库自动从环境变量加载
3. 配置文件中使用占位符 `${ENV_VAR}` 语法

### 7.3 向后兼容性保障

迁移期间保持双模式运行：

```python
def get_config():
    """兼容旧代码的配置获取"""
    try:
        return load_config()
    except FileNotFoundError:
        # 回退到旧的硬编码默认值（仅迁移期间）
        import warnings
        warnings.warn("未找到 config.yaml，使用内置默认值（已弃用）", DeprecationWarning)
        return GlobalConfig(
            crawler=CrawlerConfig(target_years=[2023]),
            # ... 其他默认值
        )
```

### 7.4 配置变更可观测性

启动时打印配置摘要（脱敏），便于排查问题：

```python
def log_config_summary(config: GlobalConfig, logger: logging.Logger):
    """打印配置摘要（脱敏）"""
    logger.info("=== 配置加载完成 ===")
    logger.info(f"  workspace_root: {config.project.workspace_root}")
    logger.info(f"  target_years: {config.crawler.target_years}")
    logger.info(f"  workers: {config.mda.behavior.workers}")
    logger.info(f"  log_level: {config.project.log_level}")
```

---
*End of Specification*
