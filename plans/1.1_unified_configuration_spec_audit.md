# 1.1 统一配置管理规格书审计报告

审计对象：`plans/1.1_unified_configuration_spec.md`

## 结论摘要

- 规格书目标明确、模块边界清晰，但存在依赖/版本不确定、配置合并策略不够可执行、路径安全校验设计偏“示例级”、以及与现有项目约定（脚本内 dataclass 配置）存在冲突等问题。
- 若按当前草案直接落地，最可能出现的失败点是：`pydantic` 版本不匹配（v1/v2 API 差异）、CLI 覆盖到嵌套字段的映射不清、以及“路径安全”规则不足以真正避免误写入危险目录。

## 审计范围

- 配置文件结构（YAML）
- Pydantic 模型设计与校验规则
- 加载与优先级/合并策略
- 实施步骤与验收标准
- 安全与可运维性（回滚、可观测性、兼容性）

## 主要问题清单（按严重性）

### P0（必须修改，否则高概率落地失败）

1) **依赖与版本未锁定，且示例代码混用 Pydantic v2 特性**
- 规格书使用 `field_validator`、`ValidationInfo`（v2）写法，但“确保 pydantic 已安装”未声明版本要求，也未评估现有依赖树。
- 风险：环境中若已有 Pydantic v1（或间接依赖引入），会直接运行失败。
- 建议：在规格书明确 `pydantic>=2,<3`（或选择 v1 并统一用 `@validator`），并将版本策略写入实现步骤与验收。

2) **配置合并策略描述偏概念化，缺少可执行的字段映射/覆盖规则**
- “命令行覆盖配置对象”未定义覆盖粒度：例如 `--year 2025` 覆盖 `spider.target_years` 还是追加？覆盖单值还是列表？
- 对嵌套字段（如 `downloader.request.timeout`）如何以 CLI 参数表达未定义。
- 建议：定义明确的覆盖语义（replace/merge/append），并给出一套最小 CLI 参数集合与映射表（CLI flag -> config path）。

3) **与项目现有开发规范冲突（dataclass 配置模式 vs Pydantic 统一配置）**
- 项目指导（`CLAUDE.md`）要求“所有脚本采用 dataclass 定义配置类，配置参数集中在 main 区域”。规格书计划改为 Pydantic 模型作为唯一数据源。
- 风险：落地时出现双配置体系并存或团队约定被破坏。
- 建议：在规格书明确迁移策略：
  - 方案 A：仍以 dataclass 为对外接口，Pydantic 仅用于加载与校验（`GlobalConfig` -> dataclass 适配）。
  - 方案 B：正式升级规范，明确 Pydantic 取代 dataclass，并同步更新约定（若允许）。

4) **`SpiderRequestConfig` 被复用到 Downloader 的 request，语义可能不一致**
- 下载与爬虫的 request 参数往往不同（chunk_size、headers、stream、retry backoff 等）。
- 风险：后续扩展被“错误复用”卡死或字段命名含混。
- 建议：拆分为 `HttpRequestConfig`（通用）+ 领域扩展，或分别定义 `SpiderRequestConfig` / `DownloaderRequestConfig`，避免“复用即耦合”。

### P1（应修改，否则会引入隐患或增加维护成本）

5) **路径安全校验规则过弱且不可移植**
- 仅检查绝对路径以 `/etc`、`/usr` 开头，未覆盖 `/bin`、`/var`、`/root`、`/home` 等敏感目录；相对路径未结合 `workspace_root` 做归一化；Windows 路径规则未覆盖。
- 也未定义“禁止写入项目源代码目录”的具体判定方法（需要 realpath/resolve 之后比较）。
- 建议：以“解析到绝对真实路径后与允许根目录做前缀匹配”的方式实现；将禁止列表与允许列表策略写入规格书。

6) **`workspace_root` 设计未说明如何作用于所有路径字段**
- YAML 中声明“所有相对路径基于此解析”，但模型中各 `Path/str` 字段没有统一的解析机制。
- 建议：定义加载流程：读取 YAML -> 构造模型 -> 执行一个“后处理/规范化”阶段，将所有路径字段转为相对于 `workspace_root` 的绝对路径（或保持相对但提供统一 `resolve_path()`）。

7) **配置文件缺失时的策略不清晰，验收标准也留有歧义**
- “建议强制要求配置文件或提供默认模板”未选定其一。
- 建议：选定策略并写入验收：
  - 强制：缺失即报错并提示生成 example。
  - 容错：缺失则用安全默认（但要列出默认值与风险）。

8) **日志与错误信息要求缺失（可运维性不足）**
- 仅提到 `log_level`，未定义日志格式、输出位置、以及 ValidationError 的用户可读提示。
- 建议：新增“错误提示规范”：配置校验失败时打印关键路径、期望类型/范围、示例修复片段。

### P2（可改进，提高可用性/一致性）

9) **字段命名与模块命名不一致：`spider` vs `crawler`**
- 现有脚本文件名是 `1.report_link_crawler.py`，规格书用 `spider`。
- 建议：统一术语（全局用 `crawler` 或 `spider`），并说明历史兼容（例如别名字段）。

10) **分析输出文件使用 `{timestamp}` 占位符但未定义格式/时区**
- 建议：规范 `timestamp` 格式（如 `YYYYMMDD_HHMMSS`）与时区（本地/UTC），避免跨平台不一致。

11) **`plate` 使用分号分隔字符串，不如列表结构清晰**
- 建议：将 `plate` 改为列表（`["sz", "sh"]`），或在模型中提供解析并校验枚举值集合。

12) **验收标准缺少“覆盖嵌套字段、路径归一化、示例配置一致性”**
- 建议补充：
  - CLI 覆盖嵌套字段至少 1 个例子（如 `--download-timeout`）。
  - `workspace_root` 生效验证（相对路径解析正确）。
  - `config.yaml.example` 与模型字段保持一致（CI 校验）。

## 缺失但建议补充的章节

1) **配置拆分与分层**：是否支持多文件（`config.yaml` + `config.local.yaml`）或 profile（dev/prod）。
2) **敏感信息处理**：目前说“非敏感配置”，但数据库路径、代理、token 等未来可能出现；建议预留环境变量注入与 `.env` 方案边界。
3) **向后兼容**：旧脚本硬编码常量如何逐步迁移、如何保证行为一致（尤其是默认值）。
4) **配置变更的可回滚性**：例如保留最近一次有效配置、启动时打印配置摘要（脱敏）。

## 可执行修订建议（最小改动优先）

1) 明确选型：Pydantic v2 或 v1，写入版本约束与理由。
2) 明确“配置缺失策略”并更新验收标准为唯一结论。
3) 给出 CLI 覆盖映射表（至少覆盖 `year/years`、`processes`、`text_root_dir`、`workers`）。
4) 定义统一路径解析规则：所有路径字段在加载后以 `workspace_root` 归一化；并定义安全校验算法（resolve 后比较）。
5) 拆分 request 配置：避免跨域复用导致未来字段冲突。
6) 统一术语：`crawler/spider` 选择其一，并在 YAML 中统一键名。

## 建议的下一步

- 先在一个脚本（建议 `1.report_link_crawler.py`）做最小可用原型验证：加载、校验、CLI 覆盖、路径归一化。
- 通过后再推进 Phase 2-4，避免一次性改造引入大范围回归。
