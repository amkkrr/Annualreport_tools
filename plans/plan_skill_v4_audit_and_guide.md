# Plan Skill v3 审计与 v4 改进指南

本文档对现有 Plan Skill v3 进行全面审计，提出 v4 改进方案，并提供实施路径。

---

## 执行摘要

### 当前状态 (v3)

Plan Skill v3 已经建立了较为完善的规划框架，包括：
- 6种基础任务类型分类
- 3级复杂度评估
- 流程矩阵和阶段库
- 3个边界协议
- 项目特定配置

### 主要问题

1. **逻辑完备性不足**
   - 缺少理解度评估维度，导致在不理解任务时强行规划
   - 缺少复合任务类型支持 (如 FEAT+REFAC)
   - 升级信号描述性强但缺少触发机制

2. **通用性受限**
   - 与具体项目 (Python/DuckDB) 耦合过紧
   - 流程矩阵固定，无法适应特殊约束
   - 缺少不同场景的流程变体

3. **边界情况覆盖不全**
   - 缺少依赖阻塞、并行任务、降级退出等协议
   - 没有紧急响应的完整流程
   - 缺少迭代式开发支持

4. **流程类型单一**
   - 所有任务都用同一套流程，缺少针对性
   - 没有探索式、迭代式等不同工作模式
   - 紧急修复流程过于简化

### 改进方向 (v4)

1. **增加理解度维度**: 在复杂度之前先评估理解程度
2. **支持复合任务**: 定义常见组合类型的处理策略
3. **自适应流程引擎**: 根据任务特征动态选择流程
4. **增强边界协议**: 覆盖更多边界情况
5. **流程模板变体**: 提供探索式、迭代式、紧急响应等变体
6. **解耦项目特定**: 分离通用核心和项目配置

---

## 详细审计

### 1. 任务分类审计

#### 现状 (v3)

| 优点 | 缺点 |
|------|------|
| 6种基础类型覆盖常见场景 | 缺少 PERF、SEC 等专门类型 |
| 决策树清晰 | 不支持复合任务 (真实场景常见) |
| 识别特征明确 | 没有任务类型变更协议 |

#### 真实场景问题

**案例1**: 新功能需要先重构现有代码
- **v3表现**: 分类为FEAT，在实现时发现需要重构，返工
- **v4改进**: 识别为 FEAT+REFAC 复合类型，先执行R3(特征测试)再进入FEAT流程

**案例2**: 修复bug发现根因是架构问题
- **v3表现**: 分类为BUG，R2后发现需要大重构，陷入困境
- **v4改进**: R2后触发"任务类型变更协议"，重新评估为BUG+REFAC或纯REFAC

**案例3**: 性能优化任务
- **v3表现**: 归到FEAT或REFAC，都不太合适
- **v4改进**: 新增PERF类型，有专门的性能分析和基准测试流程

#### 改进建议

1. **新增任务类型**: PERF (性能), SEC (安全)
2. **定义复合类型**: FEAT+REFAC, BUG+REFAC, FEAT+DOCS, PERF+REFAC, SEC+FEAT
3. **任务类型变更协议**: 当发现分类错误时的处理流程

---

### 2. 复杂度评估审计

#### 现状 (v3)

| 优点 | 缺点 |
|------|------|
| L/S/F 三级分类简洁明确 | 缺少理解度维度 |
| 文件数、接口变更等判断维度 | 升级信号缺少量化标准 |
| 有升级信号列表 | 没有自动升级机制 |

#### 真实场景问题

**案例1**: 轻量任务但完全不熟悉技术
- **v3表现**: 评为L，直接P0→实现，结果遇到大量未知
- **根因**: 缺少理解度评估
- **v4改进**: 先评估理解度为"不太清楚"，走探索式流程

**案例2**: 任务实施中发现影响范围超预期
- **v3表现**: 手动识别升级信号，询问用户是否升级
- **根因**: 升级触发器不明确
- **v4改进**: 定义量化阈值 (如文件数 \u003e 3 自动从L→S)，自适应引擎自动建议升级

**案例3**: 紧急任务但复杂度高
- **v3表现**: 要么走完整流程(时间不够)，要么跳过步骤(风险高)
- **v4改进**: 识别"时间紧迫"约束，应用快速通道变体 (缩减P2/跳过P3，事后补)

#### 改进建议

1. **新增理解度维度**: 完全清楚/基本清楚/不太清楚/完全不懂
2. **量化升级阈值**: 文件数、API变更数等具体数字
3. **约束条件识别**: 时间紧迫/质量优先/学习目标/生产问题
4. **自适应机制**: 根据理解度+复杂度+约束自动推荐流程

---

### 3. 流程设计审计

#### 现状 (v3)

| 优点 | 缺点 |
|------|------|
| 流程矩阵清晰，按类型和复杂度索引 | 流程固定，无法适应特殊场景 |
| 阶段划分合理 (P0-P4, R1-R4, I1-I2) | 缺少可选阶段 (如PoC, 安全审查) |
| 各阶段有明确输出要求 | 没有流程变体 (探索式、迭代式) |

#### 真实场景问题

**案例1**: 技术不确定性高的新功能
- **v3表现**: P1调研后仍不确定，P2设计缺乏信心
- **根因**: P1和P2之间缺少验证环节
- **v4改进**: 插入P1.5 PoC阶段，通过最小原型验证

**案例2**: 大型功能，无法一次交付
- **v3表现**: 按F级完整流程，周期长，反馈慢
- **根因**: 缺少迭代式开发流程
- **v4改进**: 提供迭代式流程模板 (MVP → 迭代1 → 迭代2)

**案例3**: 生产环境紧急故障
- **v3表现**: HOTFIX流程过于简化 (快速修复→R4)
- **根因**: 没有止血、验证、灰度等关键步骤
- **v4改进**: 增强紧急响应流程 (评估→止血→修复→验证→复盘)

**案例4**: 涉及敏感数据的功能
- **v3表现**: P3审计未覆盖安全维度
- **根因**: 缺少专门的安全审查阶段
- **v4改进**: 插入P2.5安全审查阶段 (威胁建模+安全控制)

#### 改进建议

1. **新增可选阶段**:
   - P1.5: 概念验证 (PoC)
   - P2.5: 安全审查
   - P3.5: 性能基准

2. **流程模板变体**:
   - 探索式规划流程 (理解度低)
   - 迭代式开发流程 (大型FEAT)
   - 紧急响应流程 (增强版HOTFIX)

3. **自适应流程引擎**:
   - 根据任务特征自动选择基础流程
   - 根据约束条件调整流程 (跳过/简化/增强)
   - 根据执行过程动态插入阶段

---

### 4. 边界协议审计

#### 现状 (v3)

| 协议 | 覆盖场景 | 缺失场景 |
|------|---------|---------|
| 范围膨胀 | ✓ 任务比预期复杂 | ✗ 降级/优雅退化 |
| 需求变更 | ✓ 用户修改需求 | ✗ 技术方案变更 |
| 卡死退出 | ✓ 技术阻塞、信息缺失 | ✗ 依赖阻塞、资源约束 |

#### 真实场景问题

**案例1**: 依赖外部团队的接口变更
- **v3表现**: 归到"卡死退出"，但实际可以并行推进
- **根因**: 缺少依赖阻塞协议
- **v4改进**: 识别阻塞类型，提供Mock/拆分/并行等选项

**案例2**: 多人同时开发相关功能
- **v3表现**: 各自规划，后期集成冲突
- **根因**: 缺少并行任务协议
- **v4改进**: 冲突分析+协调策略 (串行/并行/分层)

**案例3**: 发现任务过于复杂，但部分可交付
- **v3表现**: "范围膨胀"要求全部升级
- **根因**: 缺少降级退出选项
- **v4改进**: 降级协议支持MVP优先、分阶段交付

**案例4**: P2阶段发现更好的技术方案
- **v3表现**: "需求变更"协议针对用户需求，不适用
- **根因**: 缺少技术方案变更协议
- **v4改进**: 扩展需求变更协议为"需求与方案变更协议"

#### 改进建议

1. **新增协议**:
   - 依赖阻塞协议
   - 并行任务协议
   - 降级退出协议

2. **扩展现有协议**:
   - 范围膨胀 → 范围变化 (包括膨胀和缩减)
   - 需求变更 → 需求与方案变更
   - 卡死退出 → 阻塞与退出 (分类处理)

---

### 5. 通用性审计

#### 现状 (v3)

| 通用部分 | 项目特定部分 |
|---------|------------|
| 任务分类、复杂度、流程矩阵 | DuckDB、Pydantic、文件命名 |
| 阶段库 (P0-P4) | 编码规范 (来自CLAUDE.md) |
| 边界协议概念 | 审计焦点 (数据库、迁移) |

#### 问题

1. **耦合过紧**: `plan.md` 中混杂大量项目特定示例和配置
2. **难以复用**: 用于其他项目需要大量修改
3. **维护困难**: 项目配置变化需要改skill文档

#### 改进建议

**分层架构**:

```
┌─────────────────────────────────────┐
│ plan.md (通用核心)                   │
│ - 通用原则                           │
│ - 任务分类方法                       │
│ - 流程选择逻辑                       │
│ - 阶段库定义                         │
│ - 边界协议框架                       │
└─────────────────────────────────────┘
              ↓ 引用
┌─────────────────────────────────────┐
│ plan-registry.json (项目配置)        │
│ - 技术栈                             │
│ - 编码规范引用                       │
│ - 审计焦点                           │
│ - 历史教训                           │
│ - 模板路径                           │
└─────────────────────────────────────┘
              ↓ 引用
┌─────────────────────────────────────┐
│ CLAUDE.md (编码规范)                 │
│ plans/templates/ (模板文件)          │
└─────────────────────────────────────┘
```

---

## v3 vs v4 对比

### 核心改进对比表

| 维度 | v3 | v4 | 收益 |
|------|----|----|------|
| **任务分类** | 6种基础 | 8种基础+复合 | 覆盖更多真实场景 |
| **评估维度** | 仅复杂度 | 理解度+复杂度+约束 | 避免盲目规划 |
| **流程选择** | 静态矩阵 | 自适应引擎 | 动态适应场景 |
| **可选阶段** | 无 | P1.5/P2.5/P3.5 | 支持特殊需求 |
| **流程变体** | 单一 | 探索/迭代/紧急 | 匹配工作模式 |
| **边界协议** | 3个 | 6个 | 覆盖更多边界 |
| **升级机制** | 手动识别 | 量化阈值+自动建议 | 更及时准确 |
| **通用性** | 紧耦合 | 分层解耦 | 可跨项目复用 |
| **质量门** | 隐含 | 明确清单 | 可验证 |

### 场景覆盖对比

| 场景 | v3支持 | v4支持 | 改进点 |
|------|--------|--------|--------|
| 简单明确任务 | ✓ FEAT-L | ✓ 快速通道 | 流程更轻量 |
| 复杂新功能 | ✓ FEAT-F | ✓ FEAT-F + 迭代式 | 支持分阶段 |
| 技术不确定 | ✗ 强行P1→P2 | ✓ 探索式+PoC | 降低风险 |
| 复合任务 | ✗ 单一分类 | ✓ 复合类型 | 匹配真实 |
| 生产故障 | △ HOTFIX简化 | ✓ 紧急响应完整 | 更安全 |
| 性能优化 | ✗ 归到FEAT/REFAC | ✓ PERF专门流程 | 有针对性 |
| 安全功能 | △ 通用P3审计 | ✓ SEC+安全审查 | 专业性 |
| 依赖阻塞 | ✗ 归到卡死 | ✓ 依赖协议 | 多种选项 |
| 并行开发 | ✗ 无协议 | ✓ 并行协议 | 避免冲突 |
| 范围过大 | ✓ 升级 | ✓ 升级/降级/拆分 | 更灵活 |

---

## 实施路径

### 阶段1: 快速增强 (向后兼容)

**目标**: 不破坏v3，增加v4核心能力

**改动**:
1. 在 `plan.md` 开头增加"v4增强"章节
2. 新增理解度评估和快速决策树
3. 定义复合任务类型和处理策略
4. 增加可选阶段 (P1.5/P2.5/P3.5)
5. 新增3个边界协议

**工作量**: 2-4小时
**风险**: 低 (纯增量)

### 阶段2: 流程变体 (扩展)

**目标**: 提供不同场景的流程模板

**改动**:
1. 创建 `plans/templates/` 目录
2. 实现探索式规划流程模板
3. 实现迭代式开发流程模板
4. 实现紧急响应流程模板
5. 更新流程选择矩阵

**工作量**: 4-6小时
**风险**: 低 (独立模板)

### 阶段3: 自适应引擎 (重构)

**目标**: 实现智能流程选择

**改动**:
1. 设计流程选择算法 (伪代码)
2. 定义量化升级阈值
3. 实现动态阶段插入逻辑
4. 更新 `plan-registry.json` schema
5. 编写使用指南

**工作量**: 6-8小时
**风险**: 中 (需要测试验证)

### 阶段4: 解耦通用化 (可选)

**目标**: 分离通用核心和项目配置

**改动**:
1. 提取通用原则到独立章节
2. 移动项目特定内容到 plan-registry
3. 创建多个项目示例
4. 编写迁移指南

**工作量**: 4-6小时
**风险**: 低 (文档重组)

### 推荐路径

**最小可行**: 阶段1 (快速增强)
**标准路径**: 阶段1 → 阶段2
**完整升级**: 阶段1 → 阶段2 → 阶段3
**跨项目**: 全部阶段

---

## 迁移指南

### 从 v3 迁移到 v4

#### 现有计划文档

**无需修改**: v3 格式的计划文档仍然有效

**可选增强**:
- 在"问题定义"中增加理解度评估
- 复合任务明确标注主次类型
- 增加约束条件说明

#### plan-registry.json

**新增字段** (向后兼容):
```json
{
  "version": "4.0.0",  // 新增版本号

  "adaptive_engine": {  // 新增
    "enabled": true,
    "auto_upgrade": true
  },

  "workflow_customization": {  // 新增
    "team_velocity": "medium",
    "risk_tolerance": "low"
  },

  "phase_plugins": {  // 新增
    "P1.5_poc": {"enabled": true},
    "P2.5_security": {"enabled": true}
  },

  // 保留所有 v3 字段
  "task_types": {...},
  "history": {...}
}
```

#### 使用习惯

**v3 习惯**: 根据任务类型查流程矩阵
**v4 增强**: 先走快速决策树，自动推荐流程

**v3 习惯**: 发现复杂度不对手动调整
**v4 增强**: 系统自动检测升级信号并建议

---

## 测试用例

### 用例1: 简单明确的新功能

**场景**: 给配置类增加一个字段

**v3 流程**:
1. 识别: FEAT-L
2. 执行: P0→实现
3. 结果: 顺利完成

**v4 流程**:
1. 快速决策: 完全清楚 → FEAT-L → 快速通道
2. 执行: P0→实现
3. 结果: 同v3

**结论**: v4不增加负担

### 用例2: 技术不确定的新功能

**场景**: 集成一个不熟悉的第三方库

**v3 流程**:
1. 识别: FEAT-S
2. 执行: P0→P1→P2
3. **问题**: P1调研后仍不确定API用法，P2设计缺乏信心
4. 结果: 实现阶段大量返工

**v4 流程**:
1. 快速决策: 不太清楚 → 探索式流程
2. 执行: I1(调查)→P1.5(PoC验证)→重新评估
3. 发现: 实际比预期简单 → 降级为 FEAT-L
4. 执行: P0→实现
5. 结果: 减少返工

**结论**: v4 更早暴露风险

### 用例3: 需要重构的新功能

**场景**: 新增功能但现有代码难以扩展

**v3 流程**:
1. 识别: FEAT-S
2. 执行: P0→P1→P2
3. **问题**: 实现时发现需要大重构
4. 选项:
   - 硬加功能 (技术债)
   - 重新规划 (浪费P0-P2)

**v4 流程**:
1. 快速决策: 识别为 FEAT+REFAC 复合类型
2. 执行: R3(特征测试) → P0 → P1 → P2 → 重构 → FEAT实现
3. 结果: 流程顺畅

**结论**: v4 支持复合场景

### 用例4: 生产环境紧急故障

**场景**: 数据库连接池耗尽导致服务不可用

**v3 流程**:
1. 识别: HOTFIX
2. 执行: 快速修复→R4
3. **问题**: 缺少止血、验证、灰度等步骤
4. 风险: 修复可能引入新问题

**v4 流程**:
1. 识别: HOTFIX (触发紧急响应流程)
2. 执行:
   - 紧急评估 (5分钟): P0级故障
   - 止血: 重启服务+扩容连接池
   - 快速修复: 增加连接池监控告警
   - 验证: 本地→预发→灰度→全量
   - 复盘: R4 (24小时内)
3. 结果: 更安全

**结论**: v4 紧急流程更完善

### 用例5: 依赖外部团队的功能

**场景**: 需要等待后端接口开发完成

**v3 流程**:
1. 识别: FEAT-S
2. P0→P1→P2 完成设计
3. 实现阶段发现接口未就绪
4. **问题**: 归到"卡死退出"，但实际可并行
5. 结果: 等待或放弃

**v4 流程**:
1. 识别: FEAT-S
2. P1 阶段识别外部依赖
3. 触发"依赖阻塞协议"
4. 选项评估:
   - Mock接口先开发前端 (选择)
   - 并行推进，协调后端
5. 执行: Mock→开发→集成→验证
6. 结果: 不阻塞进展

**结论**: v4 依赖协议更实用

---

## 常见问题 (FAQ)

### Q1: v4 会不会过于复杂？

**A**: 分阶段实施，最小可行仅需阶段1 (快速增强)。核心是增加灵活性，不是增加复杂度。

### Q2: 理解度评估会不会主观？

**A**: 提供明确判断标准：
- 能立即说出方案 → 完全清楚
- 知道技术但不确定API → 基本清楚
- 知道要什么但不知道怎么做 → 不太清楚
- 完全陌生 → 完全不懂

### Q3: 自适应引擎如何实现？

**A**: 初期为决策辅助工具 (伪代码算法)，不是自动执行。仍需人工确认。

### Q4: 复合任务类型会不会太多？

**A**: 仅定义最常见的5-6种组合，其他按需推导。

### Q5: v3 的历史教训如何保留？

**A**: plan-registry.json 向后兼容，v4 仅新增字段。

### Q6: 如何校准复杂度评估？

**A**: 定期回顾：实际工作量 vs 预估复杂度，调整阈值。

### Q7: 流程变体会不会导致不一致？

**A**: 所有变体基于同一套阶段库，仅组合方式不同。

### Q8: 跨项目使用需要做什么？

**A**: 复制 plan.md (通用核心) + 创建新项目的 plan-registry.json。

---

## 推荐行动

### 立即行动 (今天)

1. **审阅 plan_v4_proposal.md**
2. **确认改进方向**: 是否认同理解度、复合任务、流程变体等改进
3. **选择实施路径**: 最小可行 vs 标准 vs 完整

### 短期行动 (本周)

1. **实施阶段1**: 快速增强，向后兼容
2. **测试用例验证**: 用v4处理2-3个真实任务
3. **收集反馈**: 哪些有用，哪些过度

### 中期行动 (2-4周)

1. **实施阶段2**: 流程变体
2. **更新 plan-registry**: 补充新字段
3. **团队培训**: 如果多人协作

### 长期行动 (可选)

1. **实施阶段3**: 自适应引擎
2. **积累最佳实践**: 扩展 history.successful_patterns
3. **跨项目复用**: 提取通用核心

---

## 结论

Plan Skill v3 已经建立了良好的基础，v4 改进聚焦于：

1. **更智能**: 理解度评估 + 自适应引擎
2. **更完备**: 复合任务 + 增强协议
3. **更灵活**: 流程变体 + 可选阶段
4. **更通用**: 分层解耦

**核心理念不变**: 在纸上想清楚，比在代码里试错成本低。

**v4 增强点**: 让"想清楚"这个过程更适配不同场景和约束。

---

**审计完成标记**: DONE (完成 Ralph Wiggum 循环的 completion promise)
